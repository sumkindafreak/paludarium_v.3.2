/*
 * ESP32-S3 Paludarium Controller v5.2
 * ====================================
 * - Manual boot mode (default) with auto return after 30min
 * - Enhanced Auto Logic (natural rain/waterfall, humidity-driven mist, hysteresis heater/fan, sunrise/sunset LEDs)
 * - Manual Lock 🔒 option (no auto return until user unlocks)
 * - Configurable Device Enable/Disable system for all relays
 * - Professional Web UI:
 *     🌗 Dark/Light theme toggle
 *     🟢 System Health bar
 *     📈 Trend graphs (Temp, Humidity, Light)
 *     ⚡ Quick Actions (Morning, Night, Mist Boost, Party Mode)
 *     🎛️ Manual Lock/Unlock button
 *     ⚙️ Config sliders (live-sync: humidity, mist duration, heater/fan thresholds, LED window)
 *     🔧 Device Enable/Disable toggles
 * - Config values stored in RAM only
 */

#include <DHT.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <WiFi.h>
#include <WebServer.h>
#include <WebSocketsServer.h>
#include <time.h>

// ---------- WIFI ----------
const char* WIFI_SSID = "CHANGE THIS FOR YOUR DETAILS";
const char* WIFI_PASS = "CHANGE THIS FOR YOUR DETAILS/PASSWORD";

// ---------- PINS ----------
#define PIN_WATER_LEVEL  8
#define PIN_LDR          6
#define PIN_DHT          4
#define DHT_TYPE         DHT11
#define PIN_DS18B20      5

#define RELAY_WATERFALL  12
#define RELAY_RAIN       13
#define RELAY_BUBBLE     14
#define RELAY_FAN        15
#define RELAY_HEATER     16
#define RELAY_MIST       17
#define RELAY_LED        18

// ---------- CONTROL MODE ----------
#define AUTO_TIMEOUT_MS  (30UL * 60UL * 1000UL)  // 30 minutes
bool manualMode = true;     // boot = MANUAL
bool manualSticky = false;  // true = locked in manual
unsigned long lastManualActivity = 0;

// Manual overrides
struct ManualState {
  bool rain = false, waterfall = false, bubble = false;
  bool mist = false, heater = false, fan = false, led = false;
} manualOverride;

// ---------- DEVICE ENABLE/DISABLE ----------
struct DeviceEnabled {
  bool rain = true;
  bool waterfall = false;  // disabled by default
  bool bubble = true;
  bool mist = true;
  bool heater = true;
  bool fan = true;
  bool led = true;
} deviceEnabled;

// ---------- CONFIG ----------
struct Config {
  int humidityTarget = 70;
  int mistDuration = 10;
  int heaterOn = 14;
  int heaterOff = 30;
  int fanOn = 28;
  int fanOff = 25;
  int ledDayStart = 8;
  int ledDayEnd = 20;
} config;

// ---------- WATER SENSOR ----------
#define WATER_LOW_THRESHOLD 1300

// ---------- DRIVERS ----------
DHT dht(PIN_DHT, DHT_TYPE);
OneWire oneWire(PIN_DS18B20);
DallasTemperature ds18b20(&oneWire);
WebServer server(80);
WebSocketsServer wsServer(81);

// ---------- STATE ----------
float humidity, ambientC, waterC;
int ldr, waterLevel;
bool waterOK = true;
unsigned long lastRainTime = 0;
unsigned long mistEnd = 0;
int ds18b20DeviceCount = 0;
bool ds18b20Working = false;

// ---------- HELPERS ----------
inline void relayOn(uint8_t pin){ digitalWrite(pin, LOW); }
inline void relayOff(uint8_t pin){ digitalWrite(pin, HIGH); }
inline bool relayState(uint8_t pin){ return digitalRead(pin)==LOW; }

// Enhanced relay control with enable/disable check
void safeRelayOn(uint8_t pin, bool enabled) {
  if (enabled) {
    relayOn(pin);
  } else {
    relayOff(pin);
  }
}

void safeRelayOff(uint8_t pin) {
  relayOff(pin);
}

// ---------- TIME ----------
struct tm timeinfo;
void updateTime(){ getLocalTime(&timeinfo); }

// ---------- DS18B20 ----------
void initDS18B20(){
  ds18b20.begin();
  ds18b20.setResolution(12);
  ds18b20.setWaitForConversion(true);
  ds18b20DeviceCount = ds18b20.getDeviceCount();
  ds18b20Working = (ds18b20DeviceCount > 0);
  Serial.printf("DS18B20 devices found: %d\n", ds18b20DeviceCount);
}

// ---------- SENSORS ----------
void readSensors(){
  waterLevel = analogRead(PIN_WATER_LEVEL);
  waterOK = waterLevel > WATER_LOW_THRESHOLD;
  humidity = dht.readHumidity();
  ambientC = dht.readTemperature();
  if(ds18b20Working){
    ds18b20.requestTemperatures();
    waterC = ds18b20.getTempCByIndex(0);
    if(waterC == DEVICE_DISCONNECTED_C || waterC < -55 || waterC > 125){
      waterC = -999;
    }
  } else waterC = -999;
  ldr = analogRead(PIN_LDR);
}

// ---------- MODE ----------
void setManualActivity(){
  lastManualActivity = millis();
  if(!manualMode){
    manualMode = true;
    Serial.println("🎛️ MANUAL mode (user override)");
  }
}
void checkAutoReturn(){
  if(manualMode && !manualSticky && (millis()-lastManualActivity > AUTO_TIMEOUT_MS)){
    manualMode = false;
    Serial.println("🤖 Auto-returned to AUTO mode");
  }
}

// ---------- AUTO LOGIC ----------
void runAutoLogic(){
  unsigned long now = millis();
  int hour = timeinfo.tm_hour;
  int minute = timeinfo.tm_min;

  // Rain
  static unsigned long rainEnd = 0;
  if(((hour==8 && minute<5)||(hour==20 && minute<5))||!waterOK){
    safeRelayOn(RELAY_RAIN, deviceEnabled.rain);
    rainEnd = now + 5UL*60000UL;
    lastRainTime = now;
  }
  if(now > rainEnd) safeRelayOff(RELAY_RAIN);

  // Waterfall - only runs for 30 minutes after rain stops
  static unsigned long waterfallEnd = 0;
  static bool wasRaining = false;
  bool currentlyRaining = relayState(RELAY_RAIN);

  // Detect when rain stops
  if(wasRaining && !currentlyRaining) {
    waterfallEnd = now + 30UL * 60000UL; // 30 minutes from now
    Serial.println("🌧️ Rain stopped - waterfall will run for 30 minutes");
  }
  wasRaining = currentlyRaining;

  // Control waterfall
  if(now < waterfallEnd) {
    safeRelayOn(RELAY_WATERFALL, deviceEnabled.waterfall);
  } else {
    safeRelayOff(RELAY_WATERFALL);
  }

  // Bubbles
  if(hour>=8 && hour<22){
    unsigned long cycle=(now/60000UL)%60;
    if(cycle<50) {
      safeRelayOn(RELAY_BUBBLE, deviceEnabled.bubble);
    } else {
      safeRelayOff(RELAY_BUBBLE);
    }
  } else safeRelayOff(RELAY_BUBBLE);

  // Mist
  static unsigned long mistCheck=0;
  if(now>mistCheck){
    mistCheck=now+60000UL;
    if((!isnan(humidity)&&humidity<config.humidityTarget)||(hour==12&&minute<5)||(hour==18&&minute<5)){
      mistEnd=now+config.mistDuration*60000UL;
    }
  }
  if(now<mistEnd) {
    safeRelayOn(RELAY_MIST, deviceEnabled.mist);
  } else {
    safeRelayOff(RELAY_MIST);
  }

  // Heater
  if(!isnan(ambientC)){
    if(ambientC<config.heaterOn) {
      safeRelayOn(RELAY_HEATER, deviceEnabled.heater);
    } else if(ambientC>config.heaterOff) {
      safeRelayOff(RELAY_HEATER);
    }
  }

  // Fan
  if(!isnan(ambientC)){
    if(ambientC>config.fanOn) {
      safeRelayOn(RELAY_FAN, deviceEnabled.fan);
    } else if(ambientC<config.fanOff) {
      safeRelayOff(RELAY_FAN);
    }
  }

  // LEDs
  if(hour>=config.ledDayStart && hour<config.ledDayEnd) {
    safeRelayOn(RELAY_LED, deviceEnabled.led);
  } else {
    safeRelayOff(RELAY_LED);
  }
}

// ---------- MANUAL LOGIC ----------
void runManualLogic(){
  if(manualOverride.rain && deviceEnabled.rain) relayOn(RELAY_RAIN); else relayOff(RELAY_RAIN);
  if(manualOverride.waterfall && deviceEnabled.waterfall) relayOn(RELAY_WATERFALL); else relayOff(RELAY_WATERFALL);
  if(manualOverride.bubble && deviceEnabled.bubble) relayOn(RELAY_BUBBLE); else relayOff(RELAY_BUBBLE);
  if(manualOverride.mist && deviceEnabled.mist) relayOn(RELAY_MIST); else relayOff(RELAY_MIST);
  if(manualOverride.heater && deviceEnabled.heater) relayOn(RELAY_HEATER); else relayOff(RELAY_HEATER);
  if(manualOverride.fan && deviceEnabled.fan) relayOn(RELAY_FAN); else relayOff(RELAY_FAN);
  if(manualOverride.led && deviceEnabled.led) relayOn(RELAY_LED); else relayOff(RELAY_LED);
}

// ---------- LOGIC ----------
void runLogic(){
  checkAutoReturn();
  manualMode?runManualLogic():runAutoLogic();
}

// ---------- JSON ----------
String buildJSON(){
  char timeBuf[32];
  strftime(timeBuf, sizeof(timeBuf), "%H:%M:%S", &timeinfo);

  String j = "{";
  j += "\"time\":\"" + String(timeBuf) + "\",";
  j += "\"mode\":\"" + String(manualMode ? "MANUAL" : "AUTO") + "\",";
  j += "\"sticky\":" + String(manualSticky ? "true" : "false") + ",";
  j += "\"autoIn\":" + String(manualMode ? (AUTO_TIMEOUT_MS - (millis() - lastManualActivity)) / 1000 : 0) + ",";

  j += "\"waterLevel\":" + String(waterLevel) + ",";
  j += "\"water\":\"" + String(waterOK ? "GOOD" : "LOW") + "\",";
  j += "\"humidity\":" + String(isnan(humidity) ? -1 : humidity) + ",";
  j += "\"ambient\":" + String(isnan(ambientC) ? -1 : ambientC) + ",";
  j += "\"waterC\":" + String(waterC) + ",";
  j += "\"ds18b20Status\":\"" + String(ds18b20Working ? "OK" : "ERROR") + "\",";
  j += "\"ds18b20Count\":" + String(ds18b20DeviceCount) + ",";
  j += "\"ldr\":" + String(ldr) + ",";
  j += "\"wf\":\"" + String(relayState(RELAY_WATERFALL) ? "ON" : "OFF") + "\",";
  j += "\"rain\":\"" + String(relayState(RELAY_RAIN) ? "ON" : "OFF") + "\",";
  j += "\"bubble\":\"" + String(relayState(RELAY_BUBBLE) ? "ON" : "OFF") + "\",";
  j += "\"mist\":\"" + String(relayState(RELAY_MIST) ? "ON" : "OFF") + "\",";
  j += "\"heat\":\"" + String(relayState(RELAY_HEATER) ? "ON" : "OFF") + "\",";
  j += "\"fan\":\"" + String(relayState(RELAY_FAN) ? "ON" : "OFF") + "\",";
  j += "\"led\":\"" + String(relayState(RELAY_LED) ? "ON" : "OFF") + "\",";

  j += "\"enabled\":{";
  j += "\"rain\":" + String(deviceEnabled.rain ? "true" : "false") + ",";
  j += "\"waterfall\":" + String(deviceEnabled.waterfall ? "true" : "false") + ",";
  j += "\"bubble\":" + String(deviceEnabled.bubble ? "true" : "false") + ",";
  j += "\"mist\":" + String(deviceEnabled.mist ? "true" : "false") + ",";
  j += "\"heater\":" + String(deviceEnabled.heater ? "true" : "false") + ",";
  j += "\"fan\":" + String(deviceEnabled.fan ? "true" : "false") + ",";
  j += "\"led\":" + String(deviceEnabled.led ? "true" : "false");
  j += "},";

  j += "\"config\":{";
  j += "\"humidityTarget\":" + String(config.humidityTarget) + ",";
  j += "\"mistDuration\":" + String(config.mistDuration) + ",";
  j += "\"heaterOn\":" + String(config.heaterOn) + ",";
  j += "\"heaterOff\":" + String(config.heaterOff) + ",";
  j += "\"fanOn\":" + String(config.fanOn) + ",";
  j += "\"fanOff\":" + String(config.fanOff) + ",";
  j += "\"ledDayStart\":" + String(config.ledDayStart) + ",";
  j += "\"ledDayEnd\":" + String(config.ledDayEnd);
  j += "}}";

  return j;
}

// ---------- WEB HANDLERS ----------
void handleControl(){
  setManualActivity();
  String d=server.arg("device"), s=server.arg("state");
  bool on=(s=="on");
  if(d=="rain") manualOverride.rain=on;
  else if(d=="waterfall") manualOverride.waterfall=on;
  else if(d=="bubble") manualOverride.bubble=on;
  else if(d=="mist") manualOverride.mist=on;
  else if(d=="heater") manualOverride.heater=on;
  else if(d=="fan") manualOverride.fan=on;
  else if(d=="led") manualOverride.led=on;
  server.send(200,"text/plain","OK");
}

void handleEnable(){
  String d=server.arg("device"), s=server.arg("state");
  bool enabled=(s=="true");
  if(d=="rain") deviceEnabled.rain=enabled;
  else if(d=="waterfall") deviceEnabled.waterfall=enabled;
  else if(d=="bubble") deviceEnabled.bubble=enabled;
  else if(d=="mist") deviceEnabled.mist=enabled;
  else if(d=="heater") deviceEnabled.heater=enabled;
  else if(d=="fan") deviceEnabled.fan=enabled;
  else if(d=="led") deviceEnabled.led=enabled;
  
  // If device is disabled, turn it off immediately
  if(!enabled) {
    if(d=="rain") relayOff(RELAY_RAIN);
    else if(d=="waterfall") relayOff(RELAY_WATERFALL);
    else if(d=="bubble") relayOff(RELAY_BUBBLE);
    else if(d=="mist") relayOff(RELAY_MIST);
    else if(d=="heater") relayOff(RELAY_HEATER);
    else if(d=="fan") relayOff(RELAY_FAN);
    else if(d=="led") relayOff(RELAY_LED);
  }
  
  server.send(200,"text/plain","OK");
}

void handleAutoMode(){ manualMode=false; manualSticky=false; server.send(200,"text/plain","AUTO"); }
void handleManualLock(){ manualSticky=true; manualMode=true; server.send(200,"text/plain","LOCKED"); }
void handleManualUnlock(){ manualSticky=false; server.send(200,"text/plain","UNLOCKED"); }
void handleConfig(){
  if(server.hasArg("humidity")) config.humidityTarget=server.arg("humidity").toInt();
  if(server.hasArg("mist")) config.mistDuration=server.arg("mist").toInt();
  if(server.hasArg("heaterOn")) config.heaterOn=server.arg("heaterOn").toInt();
  if(server.hasArg("heaterOff")) config.heaterOff=server.arg("heaterOff").toInt();
  if(server.hasArg("fanOn")) config.fanOn=server.arg("fanOn").toInt();
  if(server.hasArg("fanOff")) config.fanOff=server.arg("fanOff").toInt();
  if(server.hasArg("ledStart")) config.ledDayStart=server.arg("ledStart").toInt();
  if(server.hasArg("ledEnd")) config.ledDayEnd=server.arg("ledEnd").toInt();
  server.send(200,"text/plain","OK");
}

// ---------- WEB ----------
String htmlIndex(); // defined below

void setupWeb(){
  server.on("/",HTTP_GET,[](){server.send(200,"text/html",htmlIndex());});
  server.on("/status",HTTP_GET,[](){server.send(200,"application/json",buildJSON());});
  server.on("/control",HTTP_GET,handleControl);
  server.on("/enable",HTTP_GET,handleEnable);
  server.on("/auto",HTTP_GET,handleAutoMode);
  server.on("/manual/lock",HTTP_GET,handleManualLock);
  server.on("/manual/unlock",HTTP_GET,handleManualUnlock);
  server.on("/config",HTTP_GET,handleConfig);
  server.begin();
  wsServer.begin();
  wsServer.onEvent([](uint8_t num,WStype_t type,uint8_t* payload,size_t length){
    if(type==WStype_CONNECTED) {
      String msg = buildJSON();   
      wsServer.sendTXT(num, msg);
    }
  });
}

// ---------- SETUP ----------
void setup(){
  Serial.begin(115200);
  dht.begin(); initDS18B20();
  pinMode(PIN_WATER_LEVEL,INPUT); pinMode(PIN_LDR,INPUT);
  int relays[]={RELAY_WATERFALL,RELAY_RAIN,RELAY_BUBBLE,RELAY_FAN,RELAY_HEATER,RELAY_MIST,RELAY_LED};
  for(int p:relays){pinMode(p,OUTPUT);relayOff(p);}
  WiFi.begin(WIFI_SSID,WIFI_PASS);
  while(WiFi.status()!=WL_CONNECTED){delay(500);Serial.print(".");}
  Serial.println("\n✅ WiFi Connected! IP: "+WiFi.localIP().toString());
  configTime(0,0,"pool.ntp.org","time.nist.gov"); updateTime();
  setupWeb();
  Serial.println("🌐 Web server ready");
  Serial.println("📊 Controller initialized");
  Serial.println("🔧 Device Enable Status:");
  Serial.printf("  Rain: %s\n", deviceEnabled.rain ? "ENABLED" : "DISABLED");
  Serial.printf("  Waterfall: %s\n", deviceEnabled.waterfall ? "ENABLED" : "DISABLED");
  Serial.printf("  Bubble: %s\n", deviceEnabled.bubble ? "ENABLED" : "DISABLED");
  Serial.printf("  Mist: %s\n", deviceEnabled.mist ? "ENABLED" : "DISABLED");
  Serial.printf("  Heater: %s\n", deviceEnabled.heater ? "ENABLED" : "DISABLED");
  Serial.printf("  Fan: %s\n", deviceEnabled.fan ? "ENABLED" : "DISABLED");
  Serial.printf("  LED: %s\n", deviceEnabled.led ? "ENABLED" : "DISABLED");
}

// ---------- LOOP ----------
void loop(){
  server.handleClient(); 
  wsServer.loop();
  static unsigned long last=0;
  if(millis()-last>2000){
    last=millis(); 
    updateTime(); 
    readSensors(); 
    runLogic();
    String msg = buildJSON();   
    wsServer.broadcastTXT(msg);
  }
}

// ---------- WEB UI ----------
String htmlIndex() {
  return R"HTML(
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Paludarium Controller</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&family=Inter:wght@400;600&display=swap" rel="stylesheet">
<style>
body {
  margin:0; padding:20px;
  font-family: 'Inter', sans-serif;
  background:#0e1116; color:#eee;
  transition: background 0.3s, color 0.3s;
}
body.light { background:#f5f5f5; color:#222; }

.container { max-width:960px; margin:auto; }
h1 { font-family:'Orbitron', sans-serif; font-size:2em; margin:20px 0; }

.topbar { display:flex; justify-content:space-between; align-items:center; margin-bottom:20px; }
.themeToggle { padding:8px 14px; border:0; border-radius:8px; cursor:pointer; background:#333; color:#fff; }
body.light .themeToggle { background:#ddd; color:#000; }

.card {
  background:#1a1d23; border-radius:12px; padding:16px; margin:12px 0;
  box-shadow:0 2px 6px rgba(0,0,0,0.4);
}
body.light .card { background:#fff; color:#222; }

.controls { display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; }
.control {
  flex:1; min-width:110px;
  padding:10px; border-radius:8px; cursor:pointer;
  text-align:center; font-weight:600;
}
.control.on { background:#0fd36a; color:#000; }
.control.off { background:#e05a5a; color:#fff; }
.control.disabled { background:#666; color:#999; cursor:not-allowed; opacity:0.5; }

.enable-controls { display:grid; grid-template-columns:repeat(auto-fit,minmax(200px,1fr)); gap:10px; margin:10px 0; }
.enable-item { display:flex; justify-content:space-between; align-items:center; padding:8px; background:#333; border-radius:6px; }
body.light .enable-item { background:#f0f0f0; }
.enable-toggle { position:relative; width:50px; height:24px; background:#666; border-radius:12px; cursor:pointer; transition:background 0.3s; }
.enable-toggle.enabled { background:#0fd36a; }
.enable-toggle::after { content:''; position:absolute; top:2px; left:2px; width:20px; height:20px; background:#fff; border-radius:50%; transition:left 0.3s; }
.enable-toggle.enabled::after { left:28px; }

.sensor { margin:6px 0; display:flex; justify-content:space-between; }
.status.good { color:#0fd36a; font-weight:bold; }
.status.bad { color:#e05a5a; font-weight:bold; }
.status.warning { color:#ffcc00; font-weight:bold; }

.graphs { display:grid; grid-template-columns:repeat(auto-fit,minmax(280px,1fr)); gap:10px; }
canvas { width:100%; height:150px; background:#000; border-radius:6px; }

.health { font-weight:600; }
</style>
</head>
<body>
<div class="container">
  <div class="topbar">
    <button class="themeToggle" onclick="toggleTheme()">🌗 Theme</button>
    <div id="health" class="health">System Health: --</div>
  </div>
  <h1>🌿 Paludarium</h1>
  <div id="status">Connecting...</div>

  <div class="card"><h3>📈 Trends</h3>
    <div class="graphs">
      <div class="graph"><canvas id="tempGraph" width="300" height="150"></canvas></div>
      <div class="graph"><canvas id="humGraph" width="300" height="150"></canvas></div>
      <div class="graph"><canvas id="lightGraph" width="300" height="150"></canvas></div>
    </div>
  </div>

  <div class="card">
    <h3>🔧 Device Enable/Disable</h3>
    <div class="enable-controls" id="enableControls">
      <!-- Populated by JavaScript -->
    </div>
  </div>

  <div id="dynamicContent"></div>

  <div class="card">
    <h3>⚙️ Auto Settings (Live)</h3>
    <label>Humidity Target: <span id="humTargetVal">70</span>%</label>
    <input type="range" id="humTarget" min="50" max="90" value="70">
    <label>Mist Duration: <span id="mistDurVal">10</span> min</label>
    <input type="range" id="mistDur" min="1" max="20" value="10">
    <label>Heater On/Off: <span id="heatRange">18–21</span> °C</label>
    <input type="range" id="heatOn" min="10" max="25" value="18">
    <input type="range" id="heatOff" min="15" max="30" value="21">
    <label>Fan On/Off: <span id="fanRange">28–25</span> °C</label>
    <input type="range" id="fanOn" min="25" max="40" value="28">
    <input type="range" id="fanOff" min="20" max="30" value="25">
    <label>LED Daytime: <span id="ledRange">08–20</span> h</label>
    <input type="range" id="ledStart" min="0" max="23" value="8">
    <input type="range" id="ledEnd" min="0" max="23" value="20">
  </div>
</div>

<script>
let ws; let historyTemp=[],historyHum=[],historyLight=[];
let pressTimer=null; // long press timer
window.currentSticky=false;
window.currentEnabled={};

function connectWS(){
  ws=new WebSocket("ws://"+location.host+":81/");
  ws.onopen=()=>console.log("✅ Connected");
  ws.onclose=()=>setTimeout(connectWS,1500);
  ws.onmessage=(ev)=>{try{render(JSON.parse(ev.data));}catch(e){}};
}
function control(device,state){ fetch('/control?device='+device+'&state='+state); }
function toggleEnable(device){ 
  let newState = !window.currentEnabled[device];
  fetch('/enable?device='+device+'&state='+newState); 
}
function autoMode(){ fetch('/auto'); }

// Long press handlers
function controlPressStart(dev,state){
  pressTimer=setTimeout(()=>{
    if(confirm("Toggle Manual Lock?")){
      fetch('/manual/'+(window.currentSticky ? 'unlock':'lock'));
    }
  },1500);
}
function controlPressEnd(dev,state){
  if(pressTimer){
    clearTimeout(pressTimer);
    pressTimer=null;
    control(dev,state); // short press → toggle
  }
}

function renderEnableControls(enabled){
  window.currentEnabled = enabled;
  let devices = [
    {key:'rain', label:'🌧️ Rain', icon:'🌧️'},
    {key:'waterfall', label:'🏔️ Waterfall', icon:'🏔️'},
    {key:'bubble', label:'🫧 Bubbles', icon:'🫧'},
    {key:'mist', label:'🌫️ Mist', icon:'🌫️'},
    {key:'heater', label:'🔥 Heater', icon:'🔥'},
    {key:'fan', label:'🌀 Fan', icon:'🌀'},
    {key:'led', label:'💡 LEDs', icon:'💡'}
  ];
  
  let html = '';
  devices.forEach(device => {
    let isEnabled = enabled[device.key];
    html += `<div class="enable-item">
      <span>${device.icon} ${device.label}</span>
      <div class="enable-toggle ${isEnabled ? 'enabled' : ''}" onclick="toggleEnable('${device.key}')"></div>
    </div>`;
  });
  
  document.getElementById('enableControls').innerHTML = html;
}

function render(j){
  window.currentSticky=j.sticky; // track sticky
  renderEnableControls(j.enabled);
  
  let autoTime=j.mode=='MANUAL'?Math.floor(j.autoIn/60)+':'+(j.autoIn%60).toString().padStart(2,'0'):'';
  let manualLabel='📱 MANUAL MODE';
  if(j.sticky) manualLabel+=' 🔒';
  if(autoTime && !j.sticky) manualLabel+=' ('+autoTime+' to auto)';
  let modeLine=(j.mode=='AUTO'?'🤖 AUTO MODE':manualLabel);
  document.getElementById('status').innerHTML='<div class="mode '+(j.mode=='AUTO'?'auto':'manual')+'">'+modeLine+'</div>';

  document.getElementById('dynamicContent').innerHTML=
    '<div class="card"><h3>📊 Sensors</h3>'
    +'<div class="sensor">🕒 Time<strong>'+j.time+'</strong></div>'
    +'<div class="sensor">💧 Water<strong>'+j.waterLevel+'</strong><span class="status '+(j.water=='GOOD'?'good':'bad')+'">'+j.water+'</span></div>'
    +'<div class="sensor">🌊 Water Temp<strong>'+(j.waterC==-999?'ERROR':j.waterC.toFixed(1)+'°C')+'</strong><span class="status '+(j.ds18b20Status=='OK'?'good':'warning')+'">DS18B20: '+j.ds18b20Status+'</span></div>'
    +'<div class="sensor">💨 Humidity<strong>'+(j.humidity==-1?'ERROR':j.humidity.toFixed(1)+'%')+'</strong></div>'
    +'<div class="sensor">🌡️ Air<strong>'+(j.ambient==-1?'ERROR':j.ambient.toFixed(1)+'°C')+'</strong></div>'
    +'<div class="sensor">☀️ Light<strong>'+j.ldr+'</strong></div>'
    +'</div>'
    +'<div class="card"><h3>🎛️ Controls</h3><div class="controls">'
    +buttonHTML('rain','🌧️ Rain',j.rain,j.enabled.rain)
    +buttonHTML('waterfall','🏔️ Waterfall',j.wf,j.enabled.waterfall)
    +buttonHTML('bubble','🫧 Bubbles',j.bubble,j.enabled.bubble)
    +buttonHTML('mist','🌫️ Mist',j.mist,j.enabled.mist)
    +buttonHTML('heater','🔥 Heater',j.heat,j.enabled.heater)
    +buttonHTML('fan','🌀 Fan',j.fan,j.enabled.fan)
    +buttonHTML('led','💡 LEDs',j.led,j.enabled.led)
    +'<button class="control off" onclick="autoMode()" style="background:#666;color:#fff;">🤖 Return to Auto</button>'
    +'</div></div>'
    +'<div class="card"><h3>⚡ Quick Actions</h3><div class="controls">'
    +'<button class="control on" onclick="macroMorning()">🌅 Morning</button>'
    +'<button class="control off" onclick="macroNight()">🌙 Night</button>'
    +'<button class="control on" onclick="macroMist()">💨 Mist Boost</button>'
    +'<button class="control off" onclick="partyMode()">🎉 Party</button>'
    +'</div></div>';

  document.getElementById('health').textContent='DS18B20: '+j.ds18b20Status+' | Uptime: '+Math.floor(performance.now()/60000)+'m';

  if(j.waterC!=-999){ historyTemp.push(j.waterC); if(historyTemp.length>30)historyTemp.shift(); }
  if(j.humidity!=-1){ historyHum.push(j.humidity); if(historyHum.length>30)historyHum.shift(); }
  if(j.ldr!=-1){ historyLight.push(j.ldr); if(historyLight.length>30)historyLight.shift(); }
  drawGraph('tempGraph',historyTemp,'#ff6666');
  drawGraph('humGraph',historyHum,'#66ccff');
  drawGraph('lightGraph',historyLight,'#ffff66');

  humTarget.value=j.config.humidityTarget; humTargetVal.textContent=j.config.humidityTarget;
  mistDur.value=j.config.mistDuration; mistDurVal.textContent=j.config.mistDuration;
  heatOn.value=j.config.heaterOn; heatOff.value=j.config.heaterOff; heatRange.textContent=heatOn.value+"–"+heatOff.value;
  fanOn.value=j.config.fanOn; fanOff.value=j.config.fanOff; fanRange.textContent=fanOn.value+"–"+fanOff.value;
  ledStart.value=j.config.ledDayStart; ledEnd.value=j.config.ledDayEnd; ledRange.textContent=ledStart.value+"–"+ledEnd.value;
}

function buttonHTML(dev,label,state,enabled){
  if(!enabled) {
    return '<button class="control disabled">'+label+' DISABLED</button>';
  }
  return '<button class="control '+(state=='ON'?'on':'off')+'" '
    +'onmousedown="controlPressStart(\''+dev+'\',\''+(state=='ON'?'off':'on')+'\')" '
    +'onmouseup="controlPressEnd(\''+dev+'\',\''+(state=='ON'?'off':'on')+'\')" '
    +'ontouchstart="controlPressStart(\''+dev+'\',\''+(state=='ON'?'off':'on')+'\')" '
    +'ontouchend="controlPressEnd(\''+dev+'\',\''+(state=='ON'?'off':'on')+'\')">'
    +label+' '+state+'</button>';
}

// Quick actions
function macroMorning(){control('rain','on');setTimeout(()=>control('rain','off'),5000);control('led','on');}
function macroNight(){['led','fan','heater','mist'].forEach(d=>control(d,'off'));}
function macroMist(){control('mist','on');setTimeout(()=>control('mist','off'),300000);}
function partyMode(){['rain','waterfall','bubble','mist','heater','fan','led'].forEach(d=>control(d,'on'));setTimeout(()=>['rain','waterfall','bubble','mist','heater','fan','led'].forEach(d=>control(d,'off')),30000);}

// Graph drawer
function drawGraph(id,data,color){
  let c=document.getElementById(id),ctx=c.getContext('2d');
  ctx.clearRect(0,0,c.width,c.height);
  ctx.strokeStyle=color;ctx.lineWidth=2;ctx.beginPath();
  data.forEach((v,i)=>{let x=i*(c.width/30);let y=c.height-(v/100*c.height);if(i==0)ctx.moveTo(x,y);else ctx.lineTo(x,y);});
  ctx.stroke();
}

// Config sliders → live send
function sendConfig(){
  let url='/config?humidity='+humTarget.value
    +'&mist='+mistDur.value
    +'&heaterOn='+heatOn.value
    +'&heaterOff='+heatOff.value
    +'&fanOn='+fanOn.value
    +'&fanOff='+fanOff.value
    +'&ledStart='+ledStart.value
    +'&ledEnd='+ledEnd.value;
  fetch(url).catch(e=>console.error("Config send failed",e));
}
function toggleTheme(){
  document.body.classList.toggle('light');
  localStorage.setItem('theme',document.body.classList.contains('light')?'light':'dark');
}
window.onload=()=>{
  if(localStorage.getItem('theme')=='light')document.body.classList.add('light');
  [humTarget,mistDur,heatOn,heatOff,fanOn,fanOff,ledStart,ledEnd].forEach(el=>{
    el.oninput=function(){
      if(this.id=='humTarget')humTargetVal.textContent=this.value;
      if(this.id=='mistDur')mistDurVal.textContent=this.value;
      if(this.id=='heatOn'||this.id=='heatOff')heatRange.textContent=heatOn.value+"–"+heatOff.value;
      if(this.id=='fanOn'||this.id=='fanOff')fanRange.textContent=fanOn.value+"–"+fanOff.value;
      if(this.id=='ledStart'||this.id=='ledEnd')ledRange.textContent=ledStart.value+"–"+ledEnd.value;
      sendConfig();
    };
  });
};
connectWS();
</script>
</body>
</html>
)HTML";
}
